# Development Guidelines

## Conversation Guidelines

- 常に日本語で会話する
- `CLAUDE.md` を更新する場合、`見出し部分は英語` で記述し、その他の内容は基本的に日本語で記述する
- コードの説明やコメントは日本語で記述する

## Philosophy

### Core Beliefs

- **インクリメンタルな進歩をビッグバンより優先** - コンパイルが通りテストをパスする小さな変更
- **既存コードから学ぶ** - 実装前に調査と計画を行う
- **教条的よりも実用的** - プロジェクトの現実に適応する
- **巧妙なコードよりも明確な意図** - 退屈で明白であれ

### Coding Principles

- YAGNI (You Aren't Gonna Need It): 今必要じゃない機能は作らない
- DRY (Don't Repeat Yourself): 同じコードを繰り返さない
- KISS (Keep It Simple Stupid): シンプルに保つ

### Simplicity Means

- 関数/クラスごとに単一の責任
- 時期尚早な抽象化を避ける
- 巧妙なトリックは使わない - 退屈な解決策を選ぶ
- 説明が必要なら、それは複雑すぎる

## Process

### 1. Planning & Staging

複雑な作業を3〜5段階に分割。`IMPLEMENTATION_PLAN.md`に文書化：

```markdown
## Stage N: [名前]
**Goal**: [具体的な成果物]
**Success Criteria**: [テスト可能な成果]
**Tests**: [具体的なテストケース]
**Status**: [Not Started|In Progress|Complete]
```
- 進捗に応じてステータスを更新
- すべての段階が完了したらファイルを削除

### 2. Implementation Flow

1. **理解** - コードベースの既存パターンを調査
2. **テスト** - 最初にテストを書く（レッド）
3. **実装** - テストをパスする最小限のコード（グリーン）
4. **リファクタリング** - テストをパスしたまま整理
5. **コミット** - 計画にリンクした明確なメッセージで

### 3. When Stuck (After 3 Attempts)

**重要**: 問題ごとに最大3回の試行、その後は停止。

1. **失敗した内容を文書化**：
   - 試したこと
   - 具体的なエラーメッセージ
   - 失敗したと思う理由

2. **代替案を調査**：
   - 2〜3個の類似実装を見つける
   - 使用された異なるアプローチを記録

3. **基本を疑う**：
   - これは適切な抽象化レベルか？
   - より小さな問題に分割できるか？
   - 完全により単純なアプローチはあるか？

4. **異なる角度から試す**：
   - 異なるライブラリ/フレームワーク機能？
   - 異なるアーキテクチャパターン？
   - 抽象化を追加する代わりに削除？

## Technical Standards

### Architecture Principles

- **継承よりも合成** - 依存性注入を使用
- **シングルトンよりもインターフェース** - テストと柔軟性を可能にする
- **暗黙的よりも明示的** - 明確なデータフローと依存関係
- **可能な限りテスト駆動** - テストを無効化せず、修正する

### Code Quality

- **すべてのコミットは必須**：
  - 正常にコンパイルする
  - 既存のすべてのテストをパスする
  - 新機能のテストを含む
  - プロジェクトのフォーマット/リンティングに従う

- **コミット前に**：
  - フォーマッター/リンターを実行
  - 変更を自己レビュー
  - コミットメッセージが「なぜ」を説明していることを確認

### Error Handling

- 説明的なメッセージで早期に失敗
- デバッグ用のコンテキストを含める
- 適切なレベルでエラーを処理
- 例外を静かに飲み込まない

## Decision Framework

複数の有効なアプローチが存在する場合の選択基準：

1. **テスタビリティ** - これを簡単にテストできるか？
2. **可読性** - 6か月後に誰かがこれを理解できるか？
3. **一貫性** - プロジェクトのパターンと一致するか？
4. **単純性** - 動作する最も単純な解決策か？
5. **可逆性** - 後で変更するのはどれくらい難しいか？

## Project Integration

### Learning the Codebase

- 3つの類似機能/コンポーネントを見つける
- 共通パターンと慣習を特定
- 可能な場合は同じライブラリ/ユーティリティを使用
- 既存のテストパターンに従う

### Tooling

- プロジェクトの既存ビルドシステムを使用
- プロジェクトのテストフレームワークを使用
- プロジェクトのフォーマッター/リンター設定を使用
- 強い正当性なしに新しいツールを導入しない

## Quality Gates

### Definition of Done

- [ ] テストが書かれ、パスしている
- [ ] コードがプロジェクトの慣習に従っている
- [ ] リンター/フォーマッターの警告がない
- [ ] コミットメッセージが明確
- [ ] 実装が計画と一致
- [ ] イシュー番号なしのTODOがない

### Test Guidelines

- 実装ではなく、振る舞いをテスト
- 可能な場合は1テストに1アサーション
- シナリオを説明する明確なテスト名
- 既存のテストユーティリティ/ヘルパーを使用
- テストは決定論的であるべき

## Important Reminders

**絶対にしないこと**:
- コミットフックをバイパスするために`--no-verify`を使用
- テストを修正する代わりに無効化
- コンパイルしないコードをコミット
- 仮定をする - 既存コードで検証する

**常にすること**:
- 動作するコードを段階的にコミット
- 進行に応じて計画文書を更新
- 既存の実装から学ぶ
- 3回失敗した後は停止して再評価